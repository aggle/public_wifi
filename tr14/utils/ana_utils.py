"""
Detecting point sources and analyzing results
"""
import numpy as np
import pandas as pd

from utils import table_utils


######################
# SNR and detections #
######################
def normalize_stamp(stamp):
    """
    Normalize the stmap to the unit normal distribution.
    This only works with KLIP residuals, which are whitened.
    """
    # shift to mean 0
    normed_stamp = stamp - np.nanmean(stamp)
    # scale to std = 1
    normed_stamp = normed_stamp/np.nanstd(normed_stamp)
    return normed_stamp

def create_std_map(subtr_results, mode='pixel', normalize=False):
    """
    Parameters
    ----------
    subtr_results
    mode: 'pixel' or 'stamp'
    normalize: False
      transform residual stamps to N(0, 1)

    Output
    ------
    std_map : pd.DataFrame, same form as subtr_results.residuals,
      with the standard deviations
    """
    resids = subtr_results.residuals.copy()
    refs = subtr_results.references.copy()
    if normalize == True:
        resids = resids.applymap(normalize_stamp)
    if mode == 'pixel':
        # assemble everything into cubes
        # i think this would be better done with decorators
        def calc_pixelwise_std(row, subtr_results):
            # apply row-wise
            star, stamp = row.name
            # pull out the references used for this stamp
            targ_refs = refs.loc[(star, stamp)].dropna()
            # these are the residuals for the reductions of those references
            targ_residuals = resids.query("stamp_id in @targ_refs")
            # now for each array of reference residuals, compute the std
            def _calc_pixelwise_std(col):
                col = col.dropna()
                try:
                    arr = np.stack(col.values)
                except ValueError:
                    return np.nan
                # compute the std and encapsulate it to make pandas happy
                std = [np.nanstd(arr, axis=0)]
                return std
            stds = targ_residuals.apply(_calc_pixelwise_std)
            def extract(x):
                try:
                    x = x[0]
                except:
                    pass
                return x
            stds = stds.apply(extract)
            return stds
        std_map = resids.apply(lambda x: calc_pixelwise_std(x, subtr_results), axis=1)
    elif mode == 'stamp':
        # calculate the standard deviation stampwise
        std_map = subtr_results.residuals.applymap(np.nanstd)
    else:
        print("mode not recognized, please choose `pixel` or `stamp`")
        std_map = None
    return std_map


def create_snr_map(subtr_results, mode='pixelwise'):
    """
    Create an SNR map from a subtraction results tuple

    Parameters
    ----------
    subtr_results : a Results named tuple generated by a subtraction manager object

    Output
    ------
    same as the residuals dataframe, but with SNR maps instead of residuals

    """
    std_map = resids.apply(lambda x: calc_pixelwise_std(x, subtr_results), axis=1)
    snr_map = resids/snr_map
    return snr_map


